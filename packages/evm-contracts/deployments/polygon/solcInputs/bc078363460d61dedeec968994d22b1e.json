{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/babyzk/DefaultPublicSignalGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IPublicSignalGetter } from \"../interfaces/IPublicSignalGetter.sol\";\n\ncontract BabyzkDefaultPsGetter is IPublicSignalGetter {\n    /// @dev Implements the getPublicSignal function from the IPublicSignalGetter interface.\n    /// @param name The signal name, represented as the given enum (converted to uint8).\n    /// @param publicSignals The public signals, as an array of uints.\n    /// @return The public signal associated with the given name.\n    function getPublicSignal(uint8 name, uint256[] calldata publicSignals) external pure override returns (uint256) {\n        // Because in babyzk's circom circuit, the index of the public signals is the same as the enum value of the signal name,\n        // we can simply return the public signal at the index of the signal name.\n        // This is deliberately done to make the circuit easier to understand and to avoid the need for a more complex getter.\n        // However, in a more complex circuit, the order of public signals can be different from the enum values.\n        // In those cases, type designers can use a custom public signal getter to return the correct public signal.\n        return publicSignals[name];\n    }\n}\n"
    },
    "contracts/babyzk/StatefulProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { IPublicSignalGetter, IntrinsicSignalName } from \"../interfaces/IPublicSignalGetter.sol\";\nimport { IProofVerifier } from \"../interfaces/IProofVerifier.sol\";\nimport { IIssuerRegistry } from \"../interfaces/IIssuerRegistry.sol\";\nimport { ITypeRegistry } from \"../interfaces/ITypeRegistry.sol\";\nimport { IStatefulVerifier, VerifyResult } from \"../interfaces/IStatefulVerifier.sol\";\n\n/// @title BabyzkVerifier\n/// @notice\n/// @dev BabyzkVerifier is a contract that does on-chain stateful verification of zero-knowledge proofs.\ncontract BabyzkStatefulVerifier is IStatefulVerifier, Ownable {\n    error InvalidArgument(string message);\n\n    // constants\n    uint8 public constant STACK_ID = 1;\n\n    /// @dev type registry\n    ITypeRegistry private _typeRegistry;\n\n    /// @dev issuer registry\n    IIssuerRegistry private _issuerRegistry;\n\n    /// @dev BabyzkVerifier constructor\n    /// @param typeRegistry type registry contract\n    /// @param issuerRegistry issuer registry contract\n    constructor(ITypeRegistry typeRegistry, IIssuerRegistry issuerRegistry, address admin) {\n        _typeRegistry = typeRegistry;\n        _issuerRegistry = issuerRegistry;\n        transferOwnership(admin);\n    }\n\n    /// @dev static verification of zero-knowledge proofs that only checks if the proof is valid.\n    /// @dev Code duplication is deliberate for clear separation of concerns.\n    function verifyProofStatic(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 keyId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view override returns (VerifyResult) {\n        if (!_typeRegistry.isTypeFullyInitializedForStack(typeId, STACK_ID)) {\n            return VerifyResult.TYPE_UNINITIALIZED;\n        }\n\n        // static validation\n        {\n            IPublicSignalGetter psGetter = _typeRegistry.getPublicSignalGetter(typeId, STACK_ID);\n\n            // type matches\n            if (typeId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.TYPE), publicSignals)) {\n                return VerifyResult.TYPE_ID_MISMATCH;\n            }\n\n            // context matches\n            if (contextId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.CONTEXT), publicSignals)) {\n                return VerifyResult.CONTEXT_ID_MISMATCH;\n            }\n\n            // keyID matches\n            if (keyId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.KEY_ID), publicSignals)) {\n                return VerifyResult.PUBKEY_INACTIVE;\n            }\n\n            // proof is valid only if its expiration lower bound is not exceeded.\n            {\n                uint256 expiration = psGetter.getPublicSignal(uint8(IntrinsicSignalName.EXPIRATION_LB), publicSignals);\n                if (expiration < block.timestamp) {\n                    return VerifyResult.EXPIRED;\n                }\n            }\n        }\n\n        IProofVerifier verifier = _typeRegistry.getVerifier(typeId, STACK_ID);\n        // zk-SNARK proof verification\n        if (!verifier.verifyProof(proofs, publicSignals)) {\n            return VerifyResult.PROOF_INVALID;\n        }\n        // signal alias check must be done within the verifier.verifyProof.\n        // // signal alias check\n        // if (verifier.isAliased(publicSignals)) {\n        //     return VerifyResult.ALIASED_SIGNAL;\n        // }\n        return VerifyResult.OK;\n    }\n\n    /// @dev Stateful verification of zero-knowledge proofs that checks\n    ///      if the proof is valid and the issuer public key is active, and\n    ///      for revocation checks if the the smt root matches.\n    /// @dev The trust relationship between the credential and issuer is binded by\n    ///      the public key ID:\n    ///      credential <--- signed by ---- publikc key <--- authroized by ---- issuer\n    ///      As long as the issuer set the public key ID to be active, the credential is trusted by the issuer,\n    ///      However, note that it does not mean that the credential is directly generated by the issuer.\n    function verifyProofFull(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view override returns (VerifyResult) {\n        if (!_typeRegistry.isTypeFullyInitializedForStack(typeId, STACK_ID)) {\n            return VerifyResult.TYPE_UNINITIALIZED;\n        }\n\n        // full input validation\n        {\n            IPublicSignalGetter psGetter = _typeRegistry.getPublicSignalGetter(typeId, STACK_ID);\n\n            // type matches\n            if (typeId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.TYPE), publicSignals)) {\n                return VerifyResult.TYPE_ID_MISMATCH;\n            }\n\n            // context matches\n            if (contextId != psGetter.getPublicSignal(uint8(IntrinsicSignalName.CONTEXT), publicSignals)) {\n                return VerifyResult.CONTEXT_ID_MISMATCH;\n            }\n\n            // proof is valid only if the issuer public key is still active.\n            {\n                uint256 keyId = psGetter.getPublicSignal(uint8(IntrinsicSignalName.KEY_ID), publicSignals);\n                if (!_issuerRegistry.isPublicKeyActiveForStack(issuerId, keyId, STACK_ID)) {\n                    return VerifyResult.PUBKEY_INACTIVE;\n                }\n            }\n\n            // proof is valid only if its expiration lower bound is not exceeded.\n            {\n                uint256 expiration = psGetter.getPublicSignal(uint8(IntrinsicSignalName.EXPIRATION_LB), publicSignals);\n                if (expiration < block.timestamp) {\n                    return VerifyResult.EXPIRED;\n                }\n            }\n\n            // proof is valid only if the smt root matches for revocable credentials.\n            if (_typeRegistry.isRevocable(typeId)) {\n                uint256 root = psGetter.getPublicSignal(\n                    uint8(IntrinsicSignalName.SIG_REVOCATION_SMT_ROOT),\n                    publicSignals\n                );\n                uint256 currentRoot = uint256(_issuerRegistry.getSignatureStateRoot(typeId, contextId, issuerId));\n                if (currentRoot != root) {\n                    return VerifyResult.SIG_REVOCATION_SMT_ROOT_MISMATCH;\n                }\n            }\n        }\n\n        IProofVerifier verifier = _typeRegistry.getVerifier(typeId, STACK_ID);\n        // zk-SNARK proof verification\n        if (!verifier.verifyProof(proofs, publicSignals)) {\n            return VerifyResult.PROOF_INVALID;\n        }\n        // signal alias check must be done within the verifier.verifyProof.\n        // // signal alias check\n        // if (verifier.isAliased(publicSignals)) {\n        //     return VerifyResult.ALIASED_SIGNAL;\n        // }\n        return VerifyResult.OK;\n    }\n\n    /// @dev return the type registry\n    function getTypeRegistry() external view override returns (ITypeRegistry) {\n        return _typeRegistry;\n    }\n\n    /// @dev update the type registry\n    function updateTypeRegistry(ITypeRegistry typeRegistry) external onlyOwner {\n        if (typeRegistry == ITypeRegistry(address(0))) {\n            revert InvalidArgument(\"typeRegistry is zero address\");\n        }\n        emit TypeRegistryUpdated(_typeRegistry, typeRegistry);\n        _typeRegistry = typeRegistry;\n    }\n\n    /// @dev return the issuer registry\n    function getIssuerRegistry() external view override returns (IIssuerRegistry) {\n        return _issuerRegistry;\n    }\n\n    /// @dev update the issuer registry\n    function updateIssuerRegistry(IIssuerRegistry issuerRegistry) external onlyOwner {\n        if (issuerRegistry == IIssuerRegistry(address(0))) {\n            revert InvalidArgument(\"issuerRegistry is zero address\");\n        }\n        emit IssuerRegistryUpdated(_issuerRegistry, issuerRegistry);\n        _issuerRegistry = issuerRegistry;\n    }\n}\n"
    },
    "contracts/babyzk/test/ProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright (c) 2021 0KIMS association.\n    Copyright (c) [2024] Galxe.com.\n\n    Modifications to this file are part of the Galxe Identity Protocol SDK,\n    which is built using the snarkJS template and is subject to the GNU\n    General Public License v3.0.\n\n    snarkJS is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.8.4 <0.9.0;\n\ncontract BabyZKGroth16Verifier {\n    error AliasedPublicSignal();\n\n    // Scalar field size\n    uint256 constant r   = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 13382824629081054131218833335176402998433623280720282474363094935338262422270;\n    uint256 constant deltax2 = 14992997694787798298970128428651735156878746405574581777463392851219891893781;\n    uint256 constant deltay1 = 804122157291260134274964543508763620825033741658958140658682496549278923901;\n    uint256 constant deltay2 = 20795590244823410398603606172994427921866842716949936464446009005497705344370;\n\n    uint256 constant IC0x = 19764436097581810314981626268114476419304968023360522705050759260578697031462;\n    uint256 constant IC0y = 8451221249198589510842464045063602196787955791157681746389594127570869984928;\n    uint256 constant IC1x = 21274084361069811495645657261374711891271996424091601874260232553721691430414;\n    uint256 constant IC1y = 18000760790522873766821443416445254770267418552173774295864206456854759299925;\n    uint256 constant IC2x = 15406250183619285448547045124806907366410436301666555537778268068652090454826;\n    uint256 constant IC2y = 16536866637232299722780757345722186540586417773472679268766516998907360267632;\n    uint256 constant IC3x = 18374705184999687319171921539828416791438685495665607649793873489922597027600;\n    uint256 constant IC3y = 1324933125121386374556026239019389403336018576970746564093745069887950534538;\n    uint256 constant IC4x = 21457380141608127838031972036608507773411663714612203367705414415111561961277;\n    uint256 constant IC4y = 16018892444415488221673569328605540820594796341281504466704561641863116563640;\n    uint256 constant IC5x = 4410962418506163125770089415721869910260536222460700836340037001025748261657;\n    uint256 constant IC5y = 12196544090537868588257394514303562289870399093465372249911888281222653317102;\n    uint256 constant IC6x = 16355683075872354209267838353583450687199376651860741592253396291886816543862;\n    uint256 constant IC6y = 8050682799666257391554605850006270160377444038524969785464126797015352749651;\n    uint256 constant IC7x = 15130082049987335261186284021682267001157753150054785745432629861697791280041;\n    uint256 constant IC7y = 11409658019373236419032912460491744865103271076229735296217123384950365303683;\n    uint256 constant IC8x = 9239095888561578936225914783731536081988128122942802873108497080576303816484;\n    uint256 constant IC8y = 19627935081539557575283341840595370652002756337934390012485590940687364697288;\n    uint256 constant IC9x = 1544399278273077596304550000514283833778290595157696898003276405603026075525;\n    uint256 constant IC9y = 12446151319216301189634940789701302821473889204933697496346243428390391624249;\n    uint256 constant IC10x = 4936749834027810796851373254552130530859646770418885520111981651453231423245;\n    uint256 constant IC10y = 4695807811926245815954974360257940071643216870360652435028803223339780553170;\n    uint256 constant IC11x = 4386575281807163938236728588139510785832125338080551306676099982544329826031;\n    uint256 constant IC11y = 21854523620979501974914214769323826893815395641321488249328265610525413876169;\n    uint256 constant IC12x = 17087426415995636070231091668322859160271781381287693465566270886052258684849;\n    uint256 constant IC12y = 21281749810427109997695417984136831170564875549572164580740725078883719443756;\n    uint256 constant IC13x = 4694568533132038325785559030661195239336100288714016265423550859067921485661;\n    uint256 constant IC13y = 13379560590872257908754863449011215932119472869546011755200122317649852454611;\n    uint256 constant IC14x = 10550810178264882050197120045435651255510437946929704560960055862934233593614;\n    uint256 constant IC14y = 9782748714520027917613119514237169222361657844606804275223173790586411176386;\n    uint256 constant IC15x = 5914524855691587775724793258915080995144157669338156007826407442379152618637;\n    uint256 constant IC15y = 12397453008182332797283780921871184363383883818158138717833932109963434050176;\n    uint256 constant IC16x = 16837586497481772092479543877979949414951845091405932961149069997036601470834;\n    uint256 constant IC16y = 16144891566083854639395947018697451368349959925473031654640966655021187669246;\n    uint256 constant IC17x = 10567482486088980042721003523293196249588750547058227520825109679160089820321;\n    uint256 constant IC17y = 18477812318770410046283056381658040574361828280620497289914213363727644682160;\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    uint16 constant proofLength = 8;\n    uint32 constant pubSignalLength = 17;\n\n    /// @dev returns the verification keys in the order that the verifier expects them:\n    /// alpha, beta, gamma, delta, ICs..\n    function getVerificationKeys() public pure returns (uint[] memory) {\n        uint[] memory vks = new uint[](16 + pubSignalLength * 2);\n        vks[0] = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n        vks[1] = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n        vks[2] = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n        vks[3] = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n        vks[4] = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n        vks[5] = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n        vks[6] = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n        vks[7] = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n        vks[8] = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n        vks[9] = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n        vks[10] = 13382824629081054131218833335176402998433623280720282474363094935338262422270;\n        vks[11] = 14992997694787798298970128428651735156878746405574581777463392851219891893781;\n        vks[12] = 804122157291260134274964543508763620825033741658958140658682496549278923901;\n        vks[13] = 20795590244823410398603606172994427921866842716949936464446009005497705344370;\n        vks[14] = 19764436097581810314981626268114476419304968023360522705050759260578697031462;\n        vks[15] = 8451221249198589510842464045063602196787955791157681746389594127570869984928;\n        vks[16] = 21274084361069811495645657261374711891271996424091601874260232553721691430414;\n        vks[17] = 18000760790522873766821443416445254770267418552173774295864206456854759299925;\n        vks[18] = 15406250183619285448547045124806907366410436301666555537778268068652090454826;\n        vks[19] = 16536866637232299722780757345722186540586417773472679268766516998907360267632;\n        vks[20] = 18374705184999687319171921539828416791438685495665607649793873489922597027600;\n        vks[21] = 1324933125121386374556026239019389403336018576970746564093745069887950534538;\n        vks[22] = 21457380141608127838031972036608507773411663714612203367705414415111561961277;\n        vks[23] = 16018892444415488221673569328605540820594796341281504466704561641863116563640;\n        vks[24] = 4410962418506163125770089415721869910260536222460700836340037001025748261657;\n        vks[25] = 12196544090537868588257394514303562289870399093465372249911888281222653317102;\n        vks[26] = 16355683075872354209267838353583450687199376651860741592253396291886816543862;\n        vks[27] = 8050682799666257391554605850006270160377444038524969785464126797015352749651;\n        vks[28] = 15130082049987335261186284021682267001157753150054785745432629861697791280041;\n        vks[29] = 11409658019373236419032912460491744865103271076229735296217123384950365303683;\n        vks[30] = 9239095888561578936225914783731536081988128122942802873108497080576303816484;\n        vks[31] = 19627935081539557575283341840595370652002756337934390012485590940687364697288;\n        vks[32] = 1544399278273077596304550000514283833778290595157696898003276405603026075525;\n        vks[33] = 12446151319216301189634940789701302821473889204933697496346243428390391624249;\n        vks[34] = 4936749834027810796851373254552130530859646770418885520111981651453231423245;\n        vks[35] = 4695807811926245815954974360257940071643216870360652435028803223339780553170;\n        vks[36] = 4386575281807163938236728588139510785832125338080551306676099982544329826031;\n        vks[37] = 21854523620979501974914214769323826893815395641321488249328265610525413876169;\n        vks[38] = 17087426415995636070231091668322859160271781381287693465566270886052258684849;\n        vks[39] = 21281749810427109997695417984136831170564875549572164580740725078883719443756;\n        vks[40] = 4694568533132038325785559030661195239336100288714016265423550859067921485661;\n        vks[41] = 13379560590872257908754863449011215932119472869546011755200122317649852454611;\n        vks[42] = 10550810178264882050197120045435651255510437946929704560960055862934233593614;\n        vks[43] = 9782748714520027917613119514237169222361657844606804275223173790586411176386;\n        vks[44] = 5914524855691587775724793258915080995144157669338156007826407442379152618637;\n        vks[45] = 12397453008182332797283780921871184363383883818158138717833932109963434050176;\n        vks[46] = 16837586497481772092479543877979949414951845091405932961149069997036601470834;\n        vks[47] = 16144891566083854639395947018697451368349959925473031654640966655021187669246;\n        vks[48] = 10567482486088980042721003523293196249588750547058227520825109679160089820321;\n        vks[49] = 18477812318770410046283056381658040574361828280620497289914213363727644682160;\n        return vks;\n    }\n\n    /// @dev return true if the public signal is aliased\n    function isAliased(uint[] calldata _pubSignals) public pure returns (bool) {\n        // Alias check\n        if (_pubSignals[0] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[1] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[2] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[3] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[4] >= 452312848583266388373324160190187140051835877600158453279131187530910662656) { return true; }\n        if (_pubSignals[5] >= 18446744073709551616) { return true; }\n        if (_pubSignals[6] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[7] >= 904625697166532776746648320380374280103671755200316906558262375061821325312) { return true; }\n        if (_pubSignals[8] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[9] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[10] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[11] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[12] >= 18446744073709551616) { return true; }\n        if (_pubSignals[13] >= 18446744073709551616) { return true; }\n        if (_pubSignals[14] >= 512) { return true; }\n        if (_pubSignals[15] >= 512) { return true; }\n        if (_pubSignals[16] >= 4) { return true; }\n        return false;\n    }\n\n    function verifyProof(uint[] calldata _proofs, uint[] calldata _pubSignals) public view returns (bool) {\n        // Check Argument\n        require(_proofs.length == proofLength, \"Invalid proof\");\n        require(_pubSignals.length == pubSignalLength, \"Invalid public signal\");\n        if (isAliased(_pubSignals)) { return false; }\n        assembly {\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination it.vkey.vk_x\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))\n                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))\n                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))\n                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))\n                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))\n                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))\n                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))\n                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // it.vkey.vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_proofs.offset, add(_proofs.offset, 64), add(_proofs.offset, 192), _pubSignals.offset, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}"
    },
    "contracts/babyzk/test/RevocableProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright (c) 2021 0KIMS association.\n    Copyright (c) [2024] Galxe.com.\n\n    Modifications to this file are part of the Galxe Identity Protocol SDK,\n    which is built using the snarkJS template and is subject to the GNU\n    General Public License v3.0.\n\n    snarkJS is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.8.4 <0.9.0;\n\ncontract BabyZKGroth16RevocableVerifier {\n    error AliasedPublicSignal();\n\n    // Scalar field size\n    uint256 constant r   = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q   = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax  = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay  = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1  = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2  = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1  = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2  = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 = 1882364706458503005232475951038199065763410901527756464187180105229112396841;\n    uint256 constant deltax2 = 13982707264366558261146595797542785363281966817985917957620993113155283930842;\n    uint256 constant deltay1 = 3160664283412126522362163156335042446690680033366115964460170810315877756859;\n    uint256 constant deltay2 = 3361216318719617247167450609233098257971537409972105379556292018008174242993;\n\n    uint256 constant IC0x = 16344271723525745330089406167718673831229607420873253431918787878218777643278;\n    uint256 constant IC0y = 19068357211030992922788254345123980117959234850319825677618292842457691405030;\n    uint256 constant IC1x = 6014118828353164019223759243643946490962455888512110113738628213575528401078;\n    uint256 constant IC1y = 952560696260176513599650249066337469280887181447382521840961688826023614065;\n    uint256 constant IC2x = 18014663056359008200385623839092936993447069832043874378189731939631495230189;\n    uint256 constant IC2y = 16795844646742494465437498259853472142944507173403737817366815256427780734236;\n    uint256 constant IC3x = 14373415734035609721810433489583741151275932240655064686290661196403337233503;\n    uint256 constant IC3y = 1711037313693371500679228513798872233623076292082332844479396590369924301500;\n    uint256 constant IC4x = 4377713024822627456391534429519105229432261544520581999724742076362647481991;\n    uint256 constant IC4y = 3654939157182750025626238971442334937379360345622454301685395907715915786528;\n    uint256 constant IC5x = 12434842560341427381091009848886966190317018431571186985212767913582793091033;\n    uint256 constant IC5y = 960689068374467506525486367991002349267374064041230446260392423587028682797;\n    uint256 constant IC6x = 16116740122579596964080959678026860764868509051069170613097150798900574800120;\n    uint256 constant IC6y = 18625490230063446491898055124160076553956874307937109426236634069554743739504;\n    uint256 constant IC7x = 3328183361741286394228024661246306080676729522823836540770459393800572206293;\n    uint256 constant IC7y = 7727929394925246597242379189968256067843999732477725082090107983219972969086;\n    uint256 constant IC8x = 13472499580349749560725914977774410001141081275760218439463081236979741688008;\n    uint256 constant IC8y = 19530618553320463860467186577796936833360983842014858203085348959353732645230;\n    uint256 constant IC9x = 17498277990495913709037423552919656338979160919293909339937141462684017956196;\n    uint256 constant IC9y = 6257656821019173674606933263592807142929692127931766385726132437188595517970;\n    uint256 constant IC10x = 9904744704295542451075353263976479631548333459739603579416762901546454395958;\n    uint256 constant IC10y = 16865653462242999988333261656181644976255484812213305768443543308570775445853;\n    uint256 constant IC11x = 17276930714424563938521830782032618868277725616148136077827171096394434413630;\n    uint256 constant IC11y = 17596926818845562345130858017563587378698929254267990545207760627791567992437;\n    uint256 constant IC12x = 10690041012906057134648963944616475397467203110933997351171385905107603786178;\n    uint256 constant IC12y = 2426599412031276779556285272336062830283714413559998841981451603513647891427;\n    uint256 constant IC13x = 14677712908659821988951510335729733019134170755054403947488039668179369204015;\n    uint256 constant IC13y = 17861018456699773219339698494130023475752223596270757350019479155022095189599;\n    uint256 constant IC14x = 4059590728914927822667888753564200978294911732087844349849756028359048383529;\n    uint256 constant IC14y = 11851363417295131201057968329773341445724280888705510695977394342536126807843;\n    uint256 constant IC15x = 7994873373382848775309022009493019090315919998684705676392084020203450953676;\n    uint256 constant IC15y = 18423877133953363736951056196478183204211849265221023917424661421126345305172;\n    uint256 constant IC16x = 19381774082078471354145054015992261706028134987966526644430415687337728636125;\n    uint256 constant IC16y = 3041262511371001224328973897499583386865775708418990603668899165883122322535;\n    uint256 constant IC17x = 15576831529985557090169220347479648025003475911133392527968808385164396707157;\n    uint256 constant IC17y = 20786553444063989335647215616824231285883907234229069851003359096848464931780;\n    uint256 constant IC18x = 10242101596772973919673378396182430798758626758072900422483984912622144535264;\n    uint256 constant IC18y = 20964342351907694552983231154762237386081339332634359708567530724290111337773;\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    uint16 constant proofLength = 8;\n    uint32 constant pubSignalLength = 18;\n\n    /// @dev returns the verification keys in the order that the verifier expects them:\n    /// alpha, beta, gamma, delta, ICs..\n    function getVerificationKeys() public pure returns (uint[] memory) {\n        uint[] memory vks = new uint[](16 + pubSignalLength * 2);\n        vks[0] = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\n        vks[1] = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\n        vks[2] = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\n        vks[3] = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\n        vks[4] = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\n        vks[5] = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\n        vks[6] = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\n        vks[7] = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\n        vks[8] = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\n        vks[9] = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\n        vks[10] = 1882364706458503005232475951038199065763410901527756464187180105229112396841;\n        vks[11] = 13982707264366558261146595797542785363281966817985917957620993113155283930842;\n        vks[12] = 3160664283412126522362163156335042446690680033366115964460170810315877756859;\n        vks[13] = 3361216318719617247167450609233098257971537409972105379556292018008174242993;\n        vks[14] = 16344271723525745330089406167718673831229607420873253431918787878218777643278;\n        vks[15] = 19068357211030992922788254345123980117959234850319825677618292842457691405030;\n        vks[16] = 6014118828353164019223759243643946490962455888512110113738628213575528401078;\n        vks[17] = 952560696260176513599650249066337469280887181447382521840961688826023614065;\n        vks[18] = 18014663056359008200385623839092936993447069832043874378189731939631495230189;\n        vks[19] = 16795844646742494465437498259853472142944507173403737817366815256427780734236;\n        vks[20] = 14373415734035609721810433489583741151275932240655064686290661196403337233503;\n        vks[21] = 1711037313693371500679228513798872233623076292082332844479396590369924301500;\n        vks[22] = 4377713024822627456391534429519105229432261544520581999724742076362647481991;\n        vks[23] = 3654939157182750025626238971442334937379360345622454301685395907715915786528;\n        vks[24] = 12434842560341427381091009848886966190317018431571186985212767913582793091033;\n        vks[25] = 960689068374467506525486367991002349267374064041230446260392423587028682797;\n        vks[26] = 16116740122579596964080959678026860764868509051069170613097150798900574800120;\n        vks[27] = 18625490230063446491898055124160076553956874307937109426236634069554743739504;\n        vks[28] = 3328183361741286394228024661246306080676729522823836540770459393800572206293;\n        vks[29] = 7727929394925246597242379189968256067843999732477725082090107983219972969086;\n        vks[30] = 13472499580349749560725914977774410001141081275760218439463081236979741688008;\n        vks[31] = 19530618553320463860467186577796936833360983842014858203085348959353732645230;\n        vks[32] = 17498277990495913709037423552919656338979160919293909339937141462684017956196;\n        vks[33] = 6257656821019173674606933263592807142929692127931766385726132437188595517970;\n        vks[34] = 9904744704295542451075353263976479631548333459739603579416762901546454395958;\n        vks[35] = 16865653462242999988333261656181644976255484812213305768443543308570775445853;\n        vks[36] = 17276930714424563938521830782032618868277725616148136077827171096394434413630;\n        vks[37] = 17596926818845562345130858017563587378698929254267990545207760627791567992437;\n        vks[38] = 10690041012906057134648963944616475397467203110933997351171385905107603786178;\n        vks[39] = 2426599412031276779556285272336062830283714413559998841981451603513647891427;\n        vks[40] = 14677712908659821988951510335729733019134170755054403947488039668179369204015;\n        vks[41] = 17861018456699773219339698494130023475752223596270757350019479155022095189599;\n        vks[42] = 4059590728914927822667888753564200978294911732087844349849756028359048383529;\n        vks[43] = 11851363417295131201057968329773341445724280888705510695977394342536126807843;\n        vks[44] = 7994873373382848775309022009493019090315919998684705676392084020203450953676;\n        vks[45] = 18423877133953363736951056196478183204211849265221023917424661421126345305172;\n        vks[46] = 19381774082078471354145054015992261706028134987966526644430415687337728636125;\n        vks[47] = 3041262511371001224328973897499583386865775708418990603668899165883122322535;\n        vks[48] = 15576831529985557090169220347479648025003475911133392527968808385164396707157;\n        vks[49] = 20786553444063989335647215616824231285883907234229069851003359096848464931780;\n        vks[50] = 10242101596772973919673378396182430798758626758072900422483984912622144535264;\n        vks[51] = 20964342351907694552983231154762237386081339332634359708567530724290111337773;\n        return vks;\n    }\n\n    /// @dev return true if the public signal is aliased\n    function isAliased(uint[] calldata _pubSignals) public pure returns (bool) {\n        // Alias check\n        if (_pubSignals[0] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[1] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[2] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[3] >= 1461501637330902918203684832716283019655932542976) { return true; }\n        if (_pubSignals[4] >= 452312848583266388373324160190187140051835877600158453279131187530910662656) { return true; }\n        if (_pubSignals[5] >= 18446744073709551616) { return true; }\n        if (_pubSignals[6] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[7] >= 904625697166532776746648320380374280103671755200316906558262375061821325312) { return true; }\n        if (_pubSignals[8] >= 21888242871839275222246405745257275088548364400416034343698204186575808495617) { return true; }\n        if (_pubSignals[9] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[10] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[11] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[12] >= 340282366920938463463374607431768211456) { return true; }\n        if (_pubSignals[13] >= 18446744073709551616) { return true; }\n        if (_pubSignals[14] >= 18446744073709551616) { return true; }\n        if (_pubSignals[15] >= 512) { return true; }\n        if (_pubSignals[16] >= 512) { return true; }\n        if (_pubSignals[17] >= 4) { return true; }\n        return false;\n    }\n\n    function verifyProof(uint[] calldata _proofs, uint[] calldata _pubSignals) public view returns (bool) {\n        // Check Argument\n        require(_proofs.length == proofLength, \"Invalid proof\");\n        require(_pubSignals.length == pubSignalLength, \"Invalid public signal\");\n        if (isAliased(_pubSignals)) { return false; }\n        assembly {\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination it.vkey.vk_x\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\n                g1_mulAccC(_pVk, IC5x, IC5y, calldataload(add(pubSignals, 128)))\n                g1_mulAccC(_pVk, IC6x, IC6y, calldataload(add(pubSignals, 160)))\n                g1_mulAccC(_pVk, IC7x, IC7y, calldataload(add(pubSignals, 192)))\n                g1_mulAccC(_pVk, IC8x, IC8y, calldataload(add(pubSignals, 224)))\n                g1_mulAccC(_pVk, IC9x, IC9y, calldataload(add(pubSignals, 256)))\n                g1_mulAccC(_pVk, IC10x, IC10y, calldataload(add(pubSignals, 288)))\n                g1_mulAccC(_pVk, IC11x, IC11y, calldataload(add(pubSignals, 320)))\n                g1_mulAccC(_pVk, IC12x, IC12y, calldataload(add(pubSignals, 352)))\n                g1_mulAccC(_pVk, IC13x, IC13y, calldataload(add(pubSignals, 384)))\n                g1_mulAccC(_pVk, IC14x, IC14y, calldataload(add(pubSignals, 416)))\n                g1_mulAccC(_pVk, IC15x, IC15y, calldataload(add(pubSignals, 448)))\n                g1_mulAccC(_pVk, IC16x, IC16y, calldataload(add(pubSignals, 480)))\n                g1_mulAccC(_pVk, IC17x, IC17y, calldataload(add(pubSignals, 512)))\n                g1_mulAccC(_pVk, IC18x, IC18y, calldataload(add(pubSignals, 544)))\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // it.vkey.vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_proofs.offset, add(_proofs.offset, 64), add(_proofs.offset, 192), _pubSignals.offset, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}"
    },
    "contracts/ContextRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IContextRegistry } from \"./interfaces/IContextRegistry.sol\";\n\n/// @notice ContextRegistry is a contract that allows the registration of contexts.\n/// Contexts are strings that represent a specific context for credentials. They\n/// are ownerless and can be registered and used by anyone.\ncontract ContextRegistry is IContextRegistry {\n    error AlreadyExists();\n\n    // The global mapping between contexts and their contextID.\n    mapping(uint160 contextId => string context) private _registry;\n\n    /// @dev register a new context\n    function registerContext(string calldata context) external override returns (uint160) {\n        uint160 contextID = _getContextID(context);\n        if (bytes(_registry[contextID]).length != 0) {\n            revert AlreadyExists();\n        }\n        _registry[contextID] = context;\n        emit ContextRegistered(contextID, context);\n        return contextID;\n    }\n\n    /// @dev get the context for the given contextID\n    function getContext(uint160 contextId) external view override returns (string memory) {\n        return _registry[contextId];\n    }\n\n    /// @dev calculate the contextID for a given context string\n    function calculateContextID(string calldata context) external pure override returns (uint160) {\n        return _getContextID(context);\n    }\n\n    /**\n     * ContextID is the lower 160 bits of the keccak256 hash of the context string.\n     * @param context The context string to get the contextID for.\n     */\n    function _getContextID(string calldata context) private pure returns (uint160) {\n        return uint160(uint256(keccak256(abi.encodePacked(context))));\n    }\n}\n"
    },
    "contracts/interfaces/IContextRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title Context Registry Interface\ninterface IContextRegistry {\n    // Events\n    event ContextRegistered(uint160 indexed contextId, string context);\n\n    /// @dev registerContext registers a new context and returns the contextId\n    function registerContext(string calldata context) external returns (uint160);\n\n    /// @dev getContext returns the context for the given contextId\n    function getContext(uint160 contextId) external returns (string memory);\n\n    /// @dev calculate the contextID for a given context string\n    function calculateContextID(string calldata context) external pure returns (uint160);\n}\n"
    },
    "contracts/interfaces/IIssuerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @dev The status of the public key, only active public key can be used for verification.\nenum PublicKeyStatus {\n    UNINITIALIZED,\n    REVOKED,\n    ACTIVE\n}\n\n/// @dev The public key struct\nstruct PublicKey {\n    /// @dev the verification stack id that the public key is enabled for.\n    mapping(uint8 => bool) enabledVerificationStacks;\n    /// @dev the status of the public key\n    PublicKeyStatus status;\n    /// @dev the raw bytes of the public key. Not used in the contract, only for off-chain usage.\n    /// The spec for marshalling the public key is defined by the issuer.\n    bytes raw;\n}\n\n/// @dev The revoked signature ID in a sparsed merkle tree.\nstruct SignatureState {\n    /// @dev the root hash of the sparsed merkle tree.\n    bytes32 root;\n    /// @dev uri to the sparsed merkle tree, representing the revoked signature ids.\n    string treeURI;\n}\n\n/// @dev The issuer struct\nstruct Issuer {\n    /// @dev the name of the issuer\n    string name;\n    /// @dev the admin of the issuer, who can add or revoke public keys.\n    address admin;\n}\n\n/// @title IIssuerRegistry\n/// @dev The interface for the issuer registry contract.\ninterface IIssuerRegistry {\n    /// @notice Emitted when a new issuer is registered in the registry.\n    /// @param issuerId Unique identifier for the newly registered issuer.\n    /// @param name Name of the issuer registered.\n    event IssuerRegistered(uint256 indexed issuerId, string name);\n\n    /// @notice Emitted when an issuer's administrative role is transferred to a new address.\n    /// @param issuerId ID of issuer whose admin is being transferred.\n    /// @param oldAdmin Address of the current admin being replaced.\n    /// @param newAdmin Address of the new admin taking over.\n    event IssuerAdminTransferred(uint256 indexed issuerId, address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Emitted when the status of a public key is updated.\n    /// @param issuerId ID for the issuer to whom the public key belongs.\n    /// @param publicKeyId ID for the public key being updated.\n    /// @param status New status of the public key.\n    event PublicKeyStatusUpdated(uint256 indexed issuerId, uint256 indexed publicKeyId, PublicKeyStatus status);\n\n    /// @notice Emitted when the verification stack for a public key is updated.\n    /// @param issuerId Unique identifier for the issuer to whom the public key belongs.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId Identifier for the verification stack being updated.\n    /// @param enabled Boolean indicating whether the stack is enabled or disabled for the public key.\n    event PublicKeyVerificationStackUpdated(\n        uint256 indexed issuerId,\n        uint256 indexed publicKeyId,\n        uint256 indexed verificationStackId,\n        bool enabled\n    );\n\n    /// @notice Emitted when the signature state URI is updated for a specific type and context.\n    /// @param typeId Type identifier for the signature state being updated.\n    /// @param contextID Context identifier for the signature state being updated.\n    /// @param issuerId Issuer identifier related to the signature state.\n    /// @param newTreeURI New URI for the signature state tree.\n    event SignatureStateURIUpdated(\n        uint160 indexed typeId,\n        uint160 indexed contextID,\n        uint256 indexed issuerId,\n        string newTreeURI\n    );\n\n    /// @notice Emitted when the signature state root is updated for a specific type and context.\n    /// @param typeId Type identifier for the signature state being updated.\n    /// @param contextID Context identifier for the signature state being updated.\n    /// @param issuerId Issuer identifier related to the signature state.\n    /// @param newRoot New root hash for the signature state tree.\n    event SignatureStateRootUpdated(\n        uint160 indexed typeId,\n        uint160 indexed contextID,\n        uint256 indexed issuerId,\n        bytes32 newRoot\n    );\n\n    /// @dev Registers a new issuer along with their first public key and enabled verification stack.\n    /// @param name Name of the issuer to register.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @param publicKeyId  Identifier for the issuer's public key.\n    /// @param publicKeyRaw The raw public key data.\n    /// @return The unique identifier for the newly registered issuer.\n    function registerIssuer(\n        string calldata name,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external returns (uint256);\n\n    /// @dev Transfers the administrative role of an issuer to a new owner.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param newOwner Address of the new administrator.\n    function transferIssuerAdmin(uint256 issuerId, address newOwner) external;\n\n    /// @dev Adds a new public key for an issuer and enables it for a specified verification stack.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @param publicKeyId Unique identifier for the new public key.\n    /// @param publicKeyRaw The raw public key data.\n    function addPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external;\n\n    /// @dev Updates the status (active/revoked) of an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param status New status for the public key.\n    // only the issuer admin can call this function\n    function updatePublicKeyStatus(uint256 issuerId, uint256 publicKeyId, PublicKeyStatus status) external;\n\n    /// @dev Updates the verification stack association for an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId New verification stack identifier for the public key.\n    /// @param enabled Boolean indicating whether the stack is enabled for the public key.\n    function updatePublicKeyVerificationStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId,\n        bool enabled\n    ) external;\n\n    /// @dev Updates the signature state URI for a given type and context.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param treeURI New URI for the signature state.\n    function updateSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI\n    ) external;\n\n    /// @dev Updates the signature SMT root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param root New root hash for the revoked SMT.\n    function updateSignatureState(uint160 typeId, uint160 contextId, uint256 issuerId, bytes32 root) external;\n\n    /// @dev Sets both the signature SMT URI and root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param treeURI New URI for the signature state.\n    /// @param root New root hash for the signature state.\n    function setSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI,\n        bytes32 root\n    ) external;\n\n    /// @dev Retrieves the issuer data, reverts if the issuer does not exist.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return Issuer data structure containing issuer details.\n    function getIssuer(uint256 issuerId) external view returns (Issuer memory);\n\n    /// @dev Retrieves the raw public key data for an issuer's public key.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @return The raw public key data.\n    function getPublicKeyRaw(uint256 issuerId, uint256 publicKeyId) external view returns (bytes memory);\n\n    /// @dev Checks if an issuer's public key is active.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @return True if the public key is active, false otherwise.\n    function isPublicKeyActive(uint256 issuerId, uint256 publicKeyId) external view returns (bool);\n\n    /// @dev Checks if an issuer's public key is active and enabled for a specific verification stack.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @param publicKeyId Unique identifier for the public key.\n    /// @param verificationStackId Identifier for the verification stack.\n    /// @return True if the public key is active and enabled for the stack, false otherwise.\n    function isPublicKeyActiveForStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId\n    ) external view returns (bool);\n\n    /// @dev Retrieves the signature state for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The signature state.\n    function getSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view returns (SignatureState memory);\n\n    /// @dev Retrieves the signature state URI for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The URI of the signature state.\n    function getSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view returns (string memory);\n\n    /// @dev Retrieves the signature state root for a given type, context and issuer.\n    /// @param typeId Type identifier.\n    /// @param contextId Context identifier.\n    /// @param issuerId Unique identifier for the issuer.\n    /// @return The root hash of the signature state.\n    function getSignatureStateRoot(uint160 typeId, uint160 contextId, uint256 issuerId) external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/IProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title IProofVerifier\n/// @dev Interface for static verification of zero-knowledge proofs.\ninterface IProofVerifier {\n    /// @notice Retrieves the verification keys.\n    /// @dev This function is used to get the verification keys that are necessary for verifying proofs.\n    /// @return An array of `uint` representing the verification keys.\n    function getVerificationKeys() external view returns (uint256[] memory);\n\n    /// @dev Checks if the public signals are aliased. Aliased signals should never be used in proofs.\n    ///      This is useful when using proof aggregators that does not check for signal aliasing.\n    /// @param _pubSignals An array of `uint` representing the public signals.\n    /// @return A boolean value indicating if any public signal is aliased (`true`) or not (`false`).\n    function isAliased(uint256[] calldata _pubSignals) external view returns (bool);\n\n    /// @dev This function takes a cryptographic proof and public signals to verify the proof's validity.\n    /// @notice It verifies the proof and check if public signals were aliased.\n    /// @param _proofs An array of `uint` representing the proof.\n    /// @param _pubSignals An array of `uint` representing the public signals.\n    /// @return A boolean value indicating whether the proof is valid (`true`) or not (`false`).\n    function verifyProof(uint256[] calldata _proofs, uint256[] calldata _pubSignals) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IPublicSignalGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title Intrinsic Signal enum\nenum IntrinsicSignalName {\n    TYPE,\n    CONTEXT,\n    NULLIFIER,\n    EXTERNAL_NULLIFIER,\n    REVEAL_IDENTITY,\n    EXPIRATION_LB,\n    KEY_ID,\n    ID_EQUALS_TO,\n    SIG_REVOCATION_SMT_ROOT\n}\n\n/// @title Public Signal Getter Interface\n/// @dev Public signals (inputs) are represented as an array of uints in galxe identity protocol.\n///      To find the public signal for a given signal name, type designer should set a contract\n///      in the type registry that implements this interface.\ninterface IPublicSignalGetter {\n    /// @dev get the public signal for the signal name, represented as the given enum (represented as uint8), based on the public signals.\n    /// @notice Implementation must be able to handle intrinsic signals, defiend in IntrinsicSignalName enum.\n    ///         Type-specific signals support is optional.\n    /// @param name The signal name, represented as the given enum (converted to uint8).\n    /// @param publicSignals The public signals.\n    function getPublicSignal(uint8 name, uint256[] calldata publicSignals) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IStatefulVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IIssuerRegistry } from \"../interfaces/IIssuerRegistry.sol\";\nimport { ITypeRegistry } from \"../interfaces/ITypeRegistry.sol\";\n\n/// @title VerifyResult\n/// @notice Enum representing the possible results of a proof verification.\n/// Only the OK result indicates a successful verification.\nenum VerifyResult {\n    OK,\n    TYPE_UNINITIALIZED,\n    TYPE_ID_MISMATCH,\n    CONTEXT_ID_MISMATCH,\n    PUBKEY_INACTIVE,\n    SIG_REVOCATION_SMT_ROOT_MISMATCH,\n    PROOF_INVALID,\n    EXPIRED,\n    UNKNOWN_ERROR\n}\n\n/// @title IBabyzkStatefulVerifier\n/// @notice Interface for the BabyzkStatefulVerifier contract which handles on-chain stateful verification of zero-knowledge proofs.\ninterface IStatefulVerifier {\n    /// @notice Emitted when the TypeRegistry is updated.\n    /// @param oldTypeRegistry The address of the old TypeRegistry.\n    /// @param newTypeRegistry The address of the new TypeRegistry.\n    event TypeRegistryUpdated(ITypeRegistry oldTypeRegistry, ITypeRegistry newTypeRegistry);\n\n    /// @notice Emitted when the IssuerRegistry is updated.\n    /// @param oldIssuerRegistry The address of the old IssuerRegistry.\n    /// @param newIssuerRegistry The address of the new IssuerRegistry.\n    event IssuerRegistryUpdated(IIssuerRegistry oldIssuerRegistry, IIssuerRegistry newIssuerRegistry);\n\n    /// @notice Performs static verification of zero-knowledge proofs.\n    /// @param typeId The type ID of the proof to verify.\n    /// @param contextId The context ID of the proof to verify.\n    /// @param keyId The key ID associated with the proof.\n    /// @param proofs An array containing the proof data.\n    /// @param publicSignals An array containing the public signals data.\n    /// @return A value from the VerifyResult enum representing the verification result.\n    function verifyProofStatic(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 keyId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view returns (VerifyResult);\n\n    /// @notice Performs full verification of zero-knowledge proofs, including issuer public key activity and revocation checks.\n    /// @param typeId The type ID of the proof to verify.\n    /// @param contextId The context ID of the proof to verify.\n    /// @param issuerId The issuer ID associated with the proof.\n    /// @param proofs An array containing the proof data.\n    /// @param publicSignals An array containing the public signals data.\n    /// @return A value from the VerifyResult enum representing the verification result.\n    function verifyProofFull(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        uint256[] calldata proofs,\n        uint256[] calldata publicSignals\n    ) external view returns (VerifyResult);\n\n    /// @notice Returns the current TypeRegistry address.\n    /// @return The address of the TypeRegistry.\n    function getTypeRegistry() external view returns (ITypeRegistry);\n\n    /// @notice Returns the current IssuerRegistry address.\n    /// @return The address of the IssuerRegistry.\n    function getIssuerRegistry() external view returns (IIssuerRegistry);\n}\n"
    },
    "contracts/interfaces/ITypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IProofVerifier } from \"./IProofVerifier.sol\";\nimport { IPublicSignalGetter } from \"./IPublicSignalGetter.sol\";\n\n/// @title Credential Type\n/// @dev Defines the structure of a credential type.\nstruct CredentialType {\n    // @dev This flag indicates if the credential type support revocation.\n    bool revocable;\n    // @dev The address of the admin of the credential type, initially set to the creator.\n    address admin;\n    // @dev Provides a human-readable identifier for the credential.\n    string name;\n    // @dev The type specification of Galxe Identity Credential Type Schema.\n    string definition;\n    // @dev Additional context or information about the type.\n    string description;\n    // @dev A URI to an external JSON file of more information about the credential.\n    // See whitepaper for the JSON schema specification.\n    string resourceURI;\n}\n\n/// @title Credential Type Config, miscellanous.\n/// @notice To save stack space, we use this struct to store the verifier and public signal getter.\nstruct CredentialTypeMiscConfig {\n    bool revocable;\n    uint8 verificationStackId;\n    IProofVerifier verifier;\n    IPublicSignalGetter publicSignalGetter;\n}\n\n/// @title Interface for Type Registration Contract\n/// @notice This interface defines the functions for registering and managing types by users.\ninterface ITypeRegistry {\n    /// @dev Emitted when a new type is registered\n    /// @param typeID Unique identifier for the registered type\n    /// @param admin Address of the admin of the type.\n    /// @param name Name of the type\n    /// @param definition Immutable definition of the type\n    /// @param description Immutable description of the type\n    /// @param resourceURI Mutable resource URI for the type\n    event TypeRegistered(\n        uint160 indexed typeID,\n        address indexed admin,\n        string name,\n        string definition,\n        string description,\n        string resourceURI\n    );\n\n    /// @dev Emitted when the resource URI of a type is updated\n    /// @param typeID Unique identifier for the type being updated\n    /// @param oldResourceURI The previous resource URI\n    /// @param newResourceURI The new resource URI\n    event TypeResourceURIUpdated(uint160 indexed typeID, string oldResourceURI, string newResourceURI);\n\n    /// @dev Emitted when a proof verifier is updated for a type\n    /// @param typeID type id\n    /// @param verificationStackID verification stack id\n    /// @param verifier address of the verifier\n    event TypeVerifierUpdated(uint160 indexed typeID, uint8 indexed verificationStackID, address indexed verifier);\n\n    /// @dev Emitted when the intrinsic signal indexes are updated for a type\n    /// @param typeID type id\n    /// @param verificationStackID verification stack id\n    /// @param publicSignalGetter  address of the public signal getter\n    event TypePublicSignalGetterUpdated(\n        uint160 indexed typeID,\n        uint8 indexed verificationStackID,\n        address indexed publicSignalGetter\n    );\n\n    /// @dev Emitted when the admin of a type is transferred\n    /// @param typeID type id\n    /// @param oldAdmin address of the old admin\n    /// @param newAdmin address of the new admin\n    event TypeAdminTransferred(uint160 indexed typeID, address indexed oldAdmin, address indexed newAdmin);\n\n    /// @dev transfer the ownership of a type.\n    /// @param typeId type id of the type\n    /// @param newAdmin address of the new admin\n    function transferTypeAdmin(uint160 typeId, address newAdmin) external;\n\n    /// @notice set a primitive type, only callable by the admin.\n    /// @param typeId the type id of the primitive type\n    /// @param name name of the type\n    /// @param definition definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param config revocable, verifier and public signal getter.\n    function setPrimitiveType(\n        uint160 typeId,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        CredentialTypeMiscConfig calldata config\n    ) external;\n\n    /// @notice Register a new type by `msg.sender`\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) external returns (uint160);\n\n    /// @notice Register a new type by `msg.sender` with verifier and public signal getter set for a specific verification stack.\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param verifier verifier for the type\n    /// @param publicSignalGetter public signal getter for the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType1Step(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        uint8 verificationStackId,\n        IProofVerifier verifier,\n        IPublicSignalGetter publicSignalGetter\n    ) external returns (uint160);\n\n    /// @notice Update the resource URI of a type\n    /// @dev Can only be called by the type owner (`msg.sender`)\n    /// @param _id ID of the type to update\n    /// @param _resourceURI New resource URI for the type\n    function updateTypeResourceURI(uint160 _id, string calldata _resourceURI) external;\n\n    /// @dev update the verifier for a type\n    function updateTypeVerifier(uint160 typeId, uint8 verificationStackId, IProofVerifier verifier) external;\n\n    /// @dev update the verifier for a type\n    function updateTypePublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IPublicSignalGetter getter\n    ) external;\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getVerifier(uint160 typeId, uint8 verificationStackId) external view returns (IProofVerifier);\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getPublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view returns (IPublicSignalGetter);\n\n    /// @dev check if the type is fully initialized for the given verification stack.\n    /// @param typeId id of the type\n    /// @param verificationStackId id the verification stack\n    function isTypeFullyInitializedForStack(uint160 typeId, uint8 verificationStackId) external view returns (bool);\n\n    /// @dev Retrieve details of a type for the given typeID\n    /// @param _id ID of the type to retrieve\n    /// @return A `CredentialType` struct containing details of the type\n    function getType(uint160 _id) external view returns (CredentialType memory);\n\n    /// @dev Retrieve the admin of a type\n    /// @param typeId type id of the type\n    /// @return address of the admin of the type\n    function getTypeAdmin(uint160 typeId) external view returns (address);\n\n    /// @dev check if the type is revocable\n    function isRevocable(uint160 typeId) external view returns (bool);\n\n    /// @notice Calculate the typeID of a type, typeID is keccak256(creator, name) in uint160.\n    /// @param creator Address of the type creator\n    /// @param name Name of the type\n    /// @return The calculated typeID based on the creator address and type name\n    function calcTypeID(address creator, string calldata name) external pure returns (uint160);\n}\n"
    },
    "contracts/IssuerRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { IIssuerRegistry, Issuer, PublicKey, PublicKeyStatus, SignatureState } from \"./interfaces/IIssuerRegistry.sol\";\n\n// IssuerRegistry is a contract that manages the issuers and their public keys and signature state.\ncontract IssuerRegistry is IIssuerRegistry {\n    error IssuerAlreadyExists();\n    error IssuerNotExists();\n    error PublicKeyNotExists();\n    error PublicKeyAlreadyExists();\n    error NotIssuerOwner(address owner);\n    error NotOwner();\n    error InvalidName();\n\n    /// @dev all issuers, isser id = uint256(caller)\n    // mapping issuer id to issuer.\n    mapping(uint256 isserId => Issuer issuer) private _issuers;\n\n    // (issuerId, publickeyId) => PublicKey\n    mapping(uint256 issuerId => mapping(uint256 publicKeyId => PublicKey publicKey)) private _issuerPublicKeys;\n\n    // mapping of hash(credentialType, contextId, issuerId) => SignatureState.\n    mapping(uint256 credHashValue => SignatureState sigStatus) private _revocableSigStates;\n\n    /// @dev only issuer owner can call this function\n    modifier onlyIssuerAdmin(uint256 issuerId) {\n        _onlyIssuerAdmin(issuerId);\n        _;\n    }\n\n    /// @dev only issuer owner can call this function\n    function _onlyIssuerAdmin(uint256 issuerId) private view {\n        if (!_issuerExists(issuerId)) {\n            revert IssuerNotExists();\n        }\n        if (msg.sender != _issuers[issuerId].admin) {\n            revert NotIssuerOwner(_issuers[issuerId].admin);\n        }\n    }\n\n    /// @dev register a new issuer\n    // @notice the issuerId is the address of the caller, so 1 address can only have 1 issuer.\n    function registerIssuer(\n        string calldata name,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external override returns (uint256) {\n        uint256 issuerId = uint256(uint160(msg.sender));\n        // register new issuer\n        _registerNewIssuer(issuerId, name);\n        // add public key\n        _setPublicKey(issuerId, verificationStackId, publicKeyId, publicKeyRaw);\n        // transfer ownership\n        return issuerId;\n    }\n\n    /// @dev transfer the admin of the issuer\n    function transferIssuerAdmin(uint256 issuerId, address newOwner) external override onlyIssuerAdmin(issuerId) {\n        _issuers[issuerId].admin = newOwner;\n        emit IssuerAdminTransferred(issuerId, msg.sender, newOwner);\n    }\n\n    /// @dev add a new public key to the issuer.\n    // @param issuerId the id of the issuer\n    // @param verificationStackId the id of the verification stack\n    // @param publicKeyId the id of the public key\n    // @param publicKeyRaw the raw public key\n    // @notice only the issuer admin can call this function\n    // @notice the public key can only be added once, if incorrect, use a new key.\n    function addPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) external override onlyIssuerAdmin(issuerId) {\n        if (_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyAlreadyExists();\n        }\n        _setPublicKey(issuerId, verificationStackId, publicKeyId, publicKeyRaw);\n    }\n\n    /// @dev update the status of the public key.\n    function updatePublicKeyStatus(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        PublicKeyStatus status\n    ) external override onlyIssuerAdmin(issuerId) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyNotExists();\n        }\n\n        _issuerPublicKeys[issuerId][publicKeyId].status = status;\n        emit PublicKeyStatusUpdated(issuerId, publicKeyId, status);\n    }\n\n    /// @dev update the status of the public key.\n    function updatePublicKeyVerificationStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId,\n        bool enabled\n    ) external override onlyIssuerAdmin(issuerId) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyNotExists();\n        }\n\n        _issuerPublicKeys[issuerId][publicKeyId].enabledVerificationStacks[verificationStackId] = enabled;\n        emit PublicKeyVerificationStackUpdated(issuerId, publicKeyId, verificationStackId, enabled);\n    }\n\n    /// @dev set the signature state URI\n    function updateSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI\n    ) external override onlyIssuerAdmin(issuerId) {\n        uint256 key = _calculateCredentialHash(typeId, contextId, issuerId);\n        _revocableSigStates[key].treeURI = treeURI;\n        emit SignatureStateURIUpdated(typeId, contextId, issuerId, treeURI);\n    }\n\n    /// @dev set the signature state root\n    function updateSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        bytes32 root\n    ) external override onlyIssuerAdmin(issuerId) {\n        uint256 key = _calculateCredentialHash(typeId, contextId, issuerId);\n        _revocableSigStates[key].root = root;\n        emit SignatureStateRootUpdated(typeId, contextId, issuerId, root);\n    }\n\n    /// @dev set both the signature state URI and root.\n    function setSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId,\n        string calldata treeURI,\n        bytes32 root\n    ) external override onlyIssuerAdmin(issuerId) {\n        uint256 key = _calculateCredentialHash(typeId, contextId, issuerId);\n        _revocableSigStates[key] = SignatureState({ treeURI: treeURI, root: root });\n        emit SignatureStateURIUpdated(typeId, contextId, issuerId, treeURI);\n        emit SignatureStateRootUpdated(typeId, contextId, issuerId, root);\n    }\n\n    /// @dev calculate the hash of the credential, which is the key of the revocableSigStates.\n    function _calculateCredentialHash(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) private pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(typeId, contextId, issuerId)));\n    }\n\n    /// @dev register a new issuer\n    // @param issuerId the id of the issuer\n    // @param name the name of the issuer\n    function _registerNewIssuer(uint256 issuerId, string calldata name) private {\n        if (bytes(name).length == 0) {\n            revert InvalidName();\n        }\n        if (_issuerExists(issuerId)) {\n            revert IssuerAlreadyExists();\n        }\n\n        _issuers[issuerId] = Issuer({ name: name, admin: msg.sender });\n        emit IssuerRegistered(issuerId, name);\n        emit IssuerAdminTransferred(issuerId, address(0), msg.sender);\n    }\n\n    /// @dev add a new public key to the issuer\n    // @param issuerId the id of the issuer\n    // @param verificationStackId the id of the verification stack\n    // @param publicKeyId the id of the public key\n    // @param publicKeyRaw the raw public key\n    function _setPublicKey(\n        uint256 issuerId,\n        uint8 verificationStackId,\n        uint256 publicKeyId,\n        bytes calldata publicKeyRaw\n    ) private {\n        mapping(uint256 => PublicKey) storage keys = _issuerPublicKeys[issuerId];\n        keys[publicKeyId].enabledVerificationStacks[verificationStackId] = true;\n        keys[publicKeyId].status = PublicKeyStatus.ACTIVE;\n        keys[publicKeyId].raw = publicKeyRaw;\n\n        emit PublicKeyStatusUpdated(issuerId, publicKeyId, PublicKeyStatus.ACTIVE);\n        emit PublicKeyVerificationStackUpdated(issuerId, publicKeyId, verificationStackId, true);\n    }\n\n    /// @dev return the issuer, if not exists, revert.\n    function getIssuer(uint256 issuerId) external view override returns (Issuer memory) {\n        if (!_issuerExists(issuerId)) {\n            revert IssuerNotExists();\n        }\n        return _issuers[issuerId];\n    }\n\n    /// @dev return the public key, if not exists, revert.\n    function getPublicKeyRaw(uint256 issuerId, uint256 publicKeyId) external view override returns (bytes memory) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            revert PublicKeyNotExists();\n        }\n        return _issuerPublicKeys[issuerId][publicKeyId].raw;\n    }\n\n    /// @dev return if public key is active. If public key is not exists, return false.\n    function isPublicKeyActive(uint256 issuerId, uint256 publicKeyId) external view override returns (bool) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            return false;\n        }\n        return _issuerPublicKeys[issuerId][publicKeyId].status == PublicKeyStatus.ACTIVE;\n    }\n\n    /// @dev return if public key is active for the verification stack. If public key is not exists, return false.\n    function isPublicKeyActiveForStack(\n        uint256 issuerId,\n        uint256 publicKeyId,\n        uint8 verificationStackId\n    ) external view override returns (bool) {\n        if (!_publicKeyExists(issuerId, publicKeyId)) {\n            return false;\n        }\n        return\n            _issuerPublicKeys[issuerId][publicKeyId].enabledVerificationStacks[verificationStackId] &&\n            _issuerPublicKeys[issuerId][publicKeyId].status == PublicKeyStatus.ACTIVE;\n    }\n\n    /// @dev return the status of the public key, if not exists, returns UNINITIALIZED.\n    function getSignatureState(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view override returns (SignatureState memory) {\n        return _revocableSigStates[_calculateCredentialHash(typeId, contextId, issuerId)];\n    }\n\n    /// @dev return the status of the public key, if not exists, returns empty string.\n    function getSignatureStateURI(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view override returns (string memory) {\n        return _revocableSigStates[_calculateCredentialHash(typeId, contextId, issuerId)].treeURI;\n    }\n\n    /// @dev return the root of the signature state, if not exists, returns empty bytes.\n    function getSignatureStateRoot(\n        uint160 typeId,\n        uint160 contextId,\n        uint256 issuerId\n    ) external view override returns (bytes32) {\n        return _revocableSigStates[_calculateCredentialHash(typeId, contextId, issuerId)].root;\n    }\n\n    /// @dev internal function to check if the public key exists.\n    function _publicKeyExists(uint256 issuerId, uint256 publicKeyId) internal view returns (bool) {\n        return _issuerPublicKeys[issuerId][publicKeyId].status != PublicKeyStatus.UNINITIALIZED;\n    }\n\n    /// @dev internal function to check if the issuer exists.\n    function _issuerExists(uint256 issuerId) internal view returns (bool) {\n        return bytes(_issuers[issuerId].name).length != 0;\n    }\n}\n"
    },
    "contracts/TypeRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport { ITypeRegistry, CredentialType, CredentialTypeMiscConfig } from \"./interfaces/ITypeRegistry.sol\";\nimport { IProofVerifier } from \"./interfaces/IProofVerifier.sol\";\nimport { IPublicSignalGetter } from \"./interfaces/IPublicSignalGetter.sol\";\n\n/**\n * @title TypeRegistry\n * @dev A contract that allows the registration of credential types.\n *      Credential types are unique per creator and type name.\n * @notice Getters in this contract does not do any parameter validation,\n *         so callers should validate the inputs and outputs and uninitialized values will be zero.\n */\ncontract TypeRegistry is ITypeRegistry, Ownable {\n    error TypeAlreadyExists();\n    error TypeDoesNotExist();\n    error InvalidTypeName();\n    error NotTypeOwner();\n\n    /// @dev mapping from typeID to CredentialType.\n    mapping(uint160 typeId => CredentialType credType) private _credTypes;\n\n    /// @dev mapping from typeID to its verification stack's verifier.\n    /// @dev verifier typeID => verificationStackID => verifier\n    mapping(uint160 typeId => mapping(uint8 veriStackId => IProofVerifier verifier)) private _verifiers;\n\n    /// @dev mapping from typeID to its verification stack's intrinsic value .\n    /// @dev verifier typeID => verificationStackID => verifier\n    mapping(uint160 typeId => mapping(uint8 veriStackId => IPublicSignalGetter psGetter)) private _psGetters;\n\n    /// @param admin admin of the contract\n    constructor(address admin) {\n        transferOwnership(admin);\n    }\n\n    /// @notice set a primitive type, only callable by the admin.\n    /// @param typeId the type id of the primitive type\n    /// @param name name of the type\n    /// @param definition definition string\n    /// @param description description of the type\n    /// @param resourceURI mutable resource URI of the type\n    /// @param config misc config for the type\n    function setPrimitiveType(\n        uint160 typeId,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        CredentialTypeMiscConfig calldata config\n    ) external override onlyOwner {\n        // check if the type is already set by others.\n        // primitive type will have its creator as 0x0.\n        if (bytes(_credTypes[typeId].name).length != 0) {\n            revert TypeAlreadyExists();\n        }\n        if (bytes(name).length == 0) {\n            revert InvalidTypeName();\n        }\n        // save type info\n        _credTypes[typeId] = CredentialType({\n            revocable: config.revocable,\n            admin: address(0),\n            name: name,\n            definition: definition,\n            description: description,\n            resourceURI: resourceURI\n        });\n        emit TypeRegistered(typeId, address(0), name, definition, description, resourceURI);\n        // add verifier and public signal getter\n        _verifiers[typeId][config.verificationStackId] = config.verifier;\n        emit TypeVerifierUpdated(typeId, config.verificationStackId, address(config.verifier));\n        _psGetters[typeId][config.verificationStackId] = config.publicSignalGetter;\n        emit TypePublicSignalGetterUpdated(typeId, config.verificationStackId, address(config.publicSignalGetter));\n    }\n\n    /// @dev register a new type by msg.sender\n    /// @param name type name\n    /// @param definition type definition string, immutable\n    /// @param description description of the type, immutable\n    /// @param resourceURI resource URI of the type, mutable\n    /// @return typeID of the registered type\n    function registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) external override returns (uint160) {\n        return _registerType(revocable, name, definition, description, resourceURI);\n    }\n\n    /// @notice Register a new type by `msg.sender` with verifier and public signal getter set for a specific verification stack.\n    /// @param name Type name\n    /// @param definition Immutable type definition string\n    /// @param description Description of the type\n    /// @param resourceURI Mutable resource URI of the type\n    /// @param verifier verifier for the type\n    /// @param publicSignalGetter public signal getter for the type\n    /// @return typeID Unique identifier of the registered type\n    function registerType1Step(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI,\n        uint8 verificationStackId,\n        IProofVerifier verifier,\n        IPublicSignalGetter publicSignalGetter\n    ) external override returns (uint160) {\n        uint160 typeId = _registerType(revocable, name, definition, description, resourceURI);\n        // add verifier and public signal getter\n        _verifiers[typeId][verificationStackId] = verifier;\n        emit TypeVerifierUpdated(typeId, verificationStackId, address(verifier));\n        _psGetters[typeId][verificationStackId] = publicSignalGetter;\n        emit TypePublicSignalGetterUpdated(typeId, verificationStackId, address(publicSignalGetter));\n        return typeId;\n    }\n\n    /// @dev register a new type by msg.sender\n    /// @param name type name\n    /// @param definition type definition string, immutable\n    /// @param description description of the type, immutable\n    /// @param resourceURI resource URI of the type, mutable\n    /// @return typeID of the registered type\n    function _registerType(\n        bool revocable,\n        string calldata name,\n        string calldata definition,\n        string calldata description,\n        string calldata resourceURI\n    ) internal returns (uint160) {\n        uint160 credTypeID = _calcTypeID(msg.sender, name);\n        if (bytes(_credTypes[credTypeID].name).length != 0) {\n            revert TypeAlreadyExists();\n        }\n        if (bytes(name).length == 0) {\n            revert InvalidTypeName();\n        }\n        CredentialType memory credType = CredentialType({\n            revocable: revocable,\n            admin: msg.sender,\n            name: name,\n            definition: definition,\n            description: description,\n            resourceURI: resourceURI\n        });\n        _credTypes[credTypeID] = credType;\n        emit TypeRegistered(\n            credTypeID,\n            credType.admin,\n            credType.name,\n            credType.definition,\n            credType.description,\n            credType.resourceURI\n        );\n        return credTypeID;\n    }\n\n    /// @dev check if the type is fully initialized for the given verification stack.\n    /// @param typeId id of the type\n    /// @param verificationStackId id the verification stack\n    function isTypeFullyInitializedForStack(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view override returns (bool) {\n        return\n            _typeExists(typeId) &&\n            _verifiers[typeId][verificationStackId] != IProofVerifier(address(0)) &&\n            _psGetters[typeId][verificationStackId] != IPublicSignalGetter(address(0));\n    }\n\n    /// @dev transfer the ownership of a type.\n    /// @param typeId type id of the type\n    /// @param newAdmin address of the new admin\n    function transferTypeAdmin(uint160 typeId, address newAdmin) external override onlyTypeOwner(typeId) {\n        if (_credTypes[typeId].admin == address(0)) {\n            // primitive type doesn't have an admin, so the owner can't transfer it.\n            return;\n        }\n        _credTypes[typeId].admin = newAdmin;\n        emit TypeAdminTransferred(typeId, msg.sender, newAdmin);\n    }\n\n    /// @dev update the resource URI of a type\n    /// @param typeId of the type\n    /// @param uri new resource URI\n    /// TODO: resource URI specifcation: support multiple verification stack.\n    function updateTypeResourceURI(uint160 typeId, string calldata uri) external override onlyTypeOwner(typeId) {\n        emit TypeResourceURIUpdated(typeId, _credTypes[typeId].resourceURI, uri);\n        _credTypes[typeId].resourceURI = uri;\n    }\n\n    /// @dev update the verifier for a type\n    function updateTypeVerifier(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IProofVerifier verifier\n    ) external override onlyTypeOwner(typeId) {\n        _verifiers[typeId][verificationStackId] = verifier;\n        emit TypeVerifierUpdated(typeId, verificationStackId, address(verifier));\n    }\n\n    /// @dev update the public signal getter for a type\n    /// @param typeId id of the type\n    /// @param verificationStackId id of the verification stack\n    /// @param getter the address of the public signal getter\n    function updateTypePublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId,\n        IPublicSignalGetter getter\n    ) external override onlyTypeOwner(typeId) {\n        _psGetters[typeId][verificationStackId] = getter;\n        emit TypePublicSignalGetterUpdated(typeId, verificationStackId, address(getter));\n    }\n\n    /// @dev get the type for the given typeID\n    function getType(uint160 _id) external view override returns (CredentialType memory) {\n        return _credTypes[_id];\n    }\n\n    /// @dev Retrieve the admin of a type\n    /// @param typeId type id of the type\n    /// @return address of the admin of the type\n    function getTypeAdmin(uint160 typeId) external view override returns (address) {\n        /// uninitialized type, return 0x0\n        if (!_typeExists(typeId)) {\n            return address(0);\n        }\n        if (_credTypes[typeId].admin != address(0)) {\n            return _credTypes[typeId].admin;\n        }\n        return owner();\n    }\n\n    /// @dev check if the type is revocable\n    function isRevocable(uint160 typeId) external view override returns (bool) {\n        return _credTypes[typeId].revocable;\n    }\n\n    /// @dev get the verifier for the given typeID and verificationStackID.\n    function getVerifier(uint160 typeId, uint8 verificationStackId) external view override returns (IProofVerifier) {\n        return _verifiers[typeId][verificationStackId];\n    }\n\n    /// @param typeId type id of the type\n    /// @param verificationStackId verification stack id\n    function getPublicSignalGetter(\n        uint160 typeId,\n        uint8 verificationStackId\n    ) external view override returns (IPublicSignalGetter) {\n        return _psGetters[typeId][verificationStackId];\n    }\n\n    /// @dev calculate the typeID of a type\n    function calcTypeID(address creator, string calldata name) external pure override returns (uint160) {\n        return _calcTypeID(creator, name);\n    }\n\n    /// @dev calculate the typeID of a type\n    function _calcTypeID(address creator, string calldata name) private pure returns (uint160) {\n        return uint160(uint256(keccak256(abi.encodePacked(creator, name))));\n    }\n\n    /// @dev check if the type exists\n    function _typeExists(uint160 typeId) private view returns (bool) {\n        return bytes(_credTypes[typeId].name).length != 0;\n    }\n\n    /// @dev check if the caller is the owner of the type\n    function _onlyTypeOwner(uint160 typeId) private view {\n        if (!_typeExists(typeId)) {\n            revert TypeDoesNotExist();\n        }\n        // primitive type will have its creator as 0x0, so only the admin can update it.\n        if (_credTypes[typeId].admin == address(0)) {\n            if (msg.sender != owner()) {\n                revert NotTypeOwner();\n            }\n            return;\n        }\n        if (_credTypes[typeId].admin != msg.sender) {\n            revert NotTypeOwner();\n        }\n    }\n\n    modifier onlyTypeOwner(uint160 typeId) {\n        _onlyTypeOwner(typeId);\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}